import {createElement as A,fragment as B} from "./runtime.js";export const a=A(B,{},[A('h1',{},[`Mint for Elm users`]),A('p',{},[`Elm and Mint have similar goals of providing a robust and sound type`,`
`,`system with a friendly and approachable set of features.`]),A('p',{},[`They have some differences in their syntax and approach. Where Elm has a`,`
`,`Haskell-like syntax, Mint has a more friendly C-like syntax, and where`,`
`,`Elm uses functions as building blocks while Mint uses components.`]),A('p',{},[`Another area in which Elm and Mint differ is around talking to other`,`
`,`languages. Elm does not provide user-defined foreign function interfaces`,`
`,`for interacting with JavaScript code and libraries. All communication`,`
`,`between Elm and JavaScript has to go through the Elm ports. In contrast to`,`
`,`this, Mint makes it easy to inline JavaScript code directly and has no`,`
`,`concept of ports.`]),A('h2',{},[`Comments`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, single line comments are written with a `,A('code',{},[`--`]),` prefix and multiline`,`
`,`comments are written with `,A('code',{},[`{- -}`]),` and `,A('code',{},[`{-| -}`]),` for documentation comments.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`-- Hello, Joe!`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`{- Hello, Joe!`]),A('span',{class:"line"},[`   This is a multiline comment.`]),A('span',{class:"line"},[`-}`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`{-| Determine the length of a list.`]),A('span',{class:"line"},[`    length [1,2,3] == 3`]),A('span',{class:"line"},[`-}`]),A('span',{class:"line"},[`length : List a -> Int`]),A('span',{class:"line"},[`length xs =`]),A('span',{class:"line"},[`  foldl (\\_ i -> i + 1) 0 xs`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint has single line and multiline comments:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"comment"},[`// Hello, Joe!`]),`
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"comment"},[`/*`])]),A('span',{class:"line"},[A('span',{class:"comment"},[`Hello, Joe!`])]),A('span',{class:"line"},[A('span',{class:"comment"},[`This is a multiline comment.`])]),A('span',{class:"line"},[A('span',{class:"comment"},[`*/`])])])]),A('h2',{},[`Variables`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, you assign variables in let-blocks, and you cannot re-assign`,`
`,`variables within a let-block. You also cannot create a variable with the`,`
`,`same name as a variable from a higher scope.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`let`]),A('span',{class:"line"},[`  size = 50`]),A('span',{class:"line"},[`in`]),A('span',{class:"line"},[`  size`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint has the `,A('code',{},[`let`]),` keyword before its variable names. You cannot re-assign`,`
`,`variables, and you cannot shadow variables from other scopes.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`size`]),` = `,A('span',{class:"number"},[`50`])])])]),A('h2',{},[`Constants`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, constants can be defined at the top level of the module like any`,`
`,`other value and exported if desired and reference from other modules.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`module Hikers exposing (theAnswer)`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`theAnswer: Int`]),A('span',{class:"line"},[`theAnswer =`]),A('span',{class:"line"},[`  42`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, constants can be created using the `,A('code',{},[`const`]),` keyword, in specific`,`
`,`entities (like modules).`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`module`]),` `,A('span',{class:"type"},[`Answers`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`const`]),` `,A('span',{class:"type"},[`THE_ANSWER`]),` = `,A('span',{class:"number"},[`42`]),`
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`fun`]),` answer() {
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`THE_ANSWER`]),`
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}`])])]),A('p',{},[`Mint constants can be referenced from anywhere.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"comment"},[`// Answers.mint`]),`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`module`]),` `,A('span',{class:"type"},[`Answers`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`const`]),` `,A('span',{class:"type"},[`THE_ANSWER`]),` = `,A('span',{class:"number"},[`42`]),`
`]),A('span',{class:"line"},[`}`])])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"comment"},[`// Main.mint`]),`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`component`]),` `,A('span',{class:"type"},[`Main`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`fun`]),` render : `,A('span',{class:"type"},[`String`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`Number`]),`.`,A('span',{class:"variable"},[`toString`]),`(`,A('span',{class:"type"},[`Answers`]),`.`,A('span',{class:"type"},[`THE_ANSWER`]),`)
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}`])])]),A('h2',{},[`Functions`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, functions are defined as declarations that have arguments, or by`,`
`,`assigning anonymous functions to variables.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`sum x y =`]),A('span',{class:"line"},[`  x + y`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`multiply =`]),A('span',{class:"line"},[`  \\\\x y -> x * y`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`multiply 3 2`]),A('span',{class:"line"},[`-- 6`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint`,`'`,`s functions are declared using a syntax similar to Rust or JavaScript,`,`
`,`whereas anonymous functions are declared without using the `,A('code',{},[`fun`]),` keyword`,`
`,`and the name, of course.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` sum(`,A('span',{class:"variable"},[`x`]),` : `,A('span',{class:"type"},[`Number`]),`, `,A('span',{class:"variable"},[`y`]),` : `,A('span',{class:"type"},[`Number`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"variable"},[`y`]),`
`]),A('span',{class:"line"},[`}
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`multiply`]),` =
`]),A('span',{class:"line"},[`  (`,A('span',{class:"variable"},[`x`]),` : `,A('span',{class:"type"},[`Number`]),`, `,A('span',{class:"variable"},[`y`]),` : `,A('span',{class:"type"},[`Number`]),`) { `,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`*`]),` `,A('span',{class:"variable"},[`y`]),` }
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"variable"},[`multiply`]),`(`,A('span',{class:"number"},[`1`]),`, `,A('span',{class:"number"},[`2`]),`)`])])]),A('h3',{},[`Function type annotations`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, functions can `,A('strong',{},[`optionally`]),` have their argument and return types`,`
`,`annotated. These type annotations will always be checked by the compiler`,`
`,`and throw a compilation error if not valid. The compiler will still type`,`
`,`check your program using type inference if annotations are omitted.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`sum : number -> number -> number`]),A('span',{class:"line"},[`sum x y = x + y`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`mul : number -> number -> Bool -- Compile error`]),A('span',{class:"line"},[`mul x y = x * y`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint functions `,A('strong',{},[`must`]),` have their argument types annotated, while the`,`
`,`return type is optional. The types are checked just like in Elm.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` sum(`,A('span',{class:"variable"},[`x`]),` : `,A('span',{class:"type"},[`Number`]),`, `,A('span',{class:"variable"},[`y`]),` : `,A('span',{class:"type"},[`Number`]),`) : `,A('span',{class:"type"},[`Number`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"variable"},[`y`]),`
`]),A('span',{class:"line"},[`}
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`fun`]),` multiply(`,A('span',{class:"variable"},[`x`]),`: `,A('span',{class:"type"},[`Number`]),`, `,A('span',{class:"variable"},[`y`]),`: `,A('span',{class:"type"},[`Number`]),`) : `,A('span',{class:"type"},[`Bool`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`*`]),` `,A('span',{class:"variable"},[`y`]),` `,A('span',{class:"comment"},[`// compile error, type mismatch`]),`
`]),A('span',{class:"line"},[`}`])])]),A('h3',{},[`Labelled arguments`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm has no built-in way to label arguments. Instead, it is standard for a`,`
`,`function to expect a record as an argument, in which the field names would`,`
`,`serve as the argument labels. This can be combined with providing a`,`
`,`'`,`defaults`,`'`,` value of the same record type, where callers can override only`,`
`,`the fields that they want to differ from the default.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`defaultOptions =`]),A('span',{class:"line"},[`  { inside = defaultString`]),A('span',{class:"line"},[`  , each = defaultPattern,`]),A('span',{class:"line"},[`  , with = defaultReplacement`]),A('span',{class:"line"},[`  }`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`replace opts =`]),A('span',{class:"line"},[`  doReplacement opts.inside opts.each opts.with`])])]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`replace { each = ",", with = " ", inside = "A,B,C" }`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`replace { defaultOptions | inside = "A,B,C,D" }`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, functions can be called with the arguments name.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` replace(`,A('span',{class:"variable"},[`string`]),`: `,A('span',{class:"type"},[`String`]),`, `,A('span',{class:"variable"},[`pattern`]),`: `,A('span',{class:"type"},[`String`]),`, `,A('span',{class:"variable"},[`replacement`]),`: `,A('span',{class:"type"},[`String`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`go`]),`(`,A('span',{class:"variable"},[`string`]),`, `,A('span',{class:"variable"},[`pattern`]),`, `,A('span',{class:"variable"},[`replacement`]),`)
`]),A('span',{class:"line"},[`}`])])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"variable"},[`replace`]),`(`,A('span',{class:"variable"},[`pattern`]),`: `,A('span',{class:"string"},[`","`]),`, `,A('span',{class:"variable"},[`replacement`]),`: `,A('span',{class:"string"},[`" "`]),`, `,A('span',{class:"variable"},[`string`]),`: `,A('span',{class:"string"},[`"A,B,C"`]),`)`])])]),A('p',{},[`There is no performance cost to Mint`,`'`,`s labelled arguments, as they are`,`
`,`optimized to regular function calls at compile time, and all the arguments`,`
`,`are fully type checked.`]),A('h2',{},[`Modules`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, the `,A('code',{},[`module`]),` keyword allows creating a module. Each module maps to`,`
`,`a single file. The module name must be explicitly stated and must match the`,`
`,`file name.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`module Foo exposing (identity)`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`identity : a -> a`]),A('span',{class:"line"},[`identity x =`]),A('span',{class:"line"},[`  x`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint is using the `,A('code',{},[`module`]),` keyword as well, and any entity defined inside`,`
`,`its block belongs to the module. Because of this, modules are not tied to`,`
`,`files.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`module`]),` `,A('span',{class:"type"},[`One`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`fun`]),` identity(`,A('span',{class:"variable"},[`x`]),` : `,A('span',{class:"type_parameter"},[`a`]),`) : `,A('span',{class:"type_parameter"},[`a`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"variable"},[`x`]),`
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`component`]),` `,A('span',{class:"type"},[`Main`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`fun`]),` render : `,A('span',{class:"type"},[`String`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`One`]),`.`,A('span',{class:"variable"},[`identity`]),`(`,A('span',{class:"string"},[`"one"`]),`)
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}`])])]),A('h3',{},[`Exports`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, exports are handled at the top of the file in the module`,`
`,`declaration as a list of names.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`module Math exposing (sum)`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`-- this is public as it is in the export list`]),A('span',{class:"line"},[`sum x y =`]),A('span',{class:"line"},[`  x + y`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`-- this is private as it isn't in the export list`]),A('span',{class:"line"},[`mul x y =`]),A('span',{class:"line"},[`  x * y`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint everything is public. Since nothing is overrideable there is no need`,`
`,`for private entities.`]),A('h2',{},[`Blocks`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, expressions can be grouped using `,A('code',{},[`let`]),` and `,A('code',{},[`in`]),`.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`view =`]),A('span',{class:"line"},[`  let`]),A('span',{class:"line"},[`    x = 5`]),A('span',{class:"line"},[`    y =`]),A('span',{class:"line"},[`      let`]),A('span',{class:"line"},[`        z = 4`]),A('span',{class:"line"},[`        t = 3`]),A('span',{class:"line"},[`      in`]),A('span',{class:"line"},[`        z + (t * 5)`]),A('span',{class:"line"},[`  in`]),A('span',{class:"line"},[`    y + x`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, braces `,A('code',{},[`{`]),` `,A('code',{},[`}`]),` are used to group expressions.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` calculate {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`x`]),` =
`]),A('span',{class:"line"},[`    {
`]),A('span',{class:"line"},[`      `,A('span',{class:"variable"},[`print`]),`(`,A('span',{class:"number"},[`1`]),`)
`]),A('span',{class:"line"},[`      `,A('span',{class:"number"},[`2`]),`
`]),A('span',{class:"line"},[`    }
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`y`]),` =
`]),A('span',{class:"line"},[`    `,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`*`]),` (`,A('span',{class:"variable"},[`x`]),` `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"number"},[`10`]),`)
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`y`]),`
`]),A('span',{class:"line"},[`}`])])]),A('h2',{},[`Data types`]),A('h3',{},[`Numbers`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm has `,A('code',{},[`Int`]),` and `,A('code',{},[`Float`]),` as separate number types, and it has a built-in`,`
`,A('code',{},[`number`]),` concept that allows it to treat `,A('code',{},[`Int`]),` and `,A('code',{},[`Float`]),` generically, so`,`
`,`operators like `,A('code',{},[`+`]),` can be used for two `,A('code',{},[`Int`]),` values or two `,A('code',{},[`Float`]),` values`,`
`,`though not for an `,A('code',{},[`Int`]),` and a `,A('code',{},[`Float`])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint has no integer type and only a single floating-point `,A('code',{},[`Number`])]),A('h3',{},[`Strings`]),A('p',{},[`Both languages use double quotes for strings.`]),A('p',{},[A('strong',{},[`Elm`])]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`"Hello, world!"`])])]),A('p',{},[`Strings in Elm are combined using the `,A('code',{},[`++`]),` operator.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`greeting =`]),A('span',{class:"line"},[`  "Hello, " ++ "world!"`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"string"},[`"Hello, world!"`])])])]),A('p',{},[`Similar to Elm, you can combine strings, for that Mint uses the operator `,A('code',{},[`+`])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`greeting`]),` =
`]),A('span',{class:"line"},[`  `,A('span',{class:"string"},[`"Hello, "`]),` `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"string"},[`"world!"`])])])]),A('h3',{},[`Tuples`]),A('p',{},[`Tuples are very useful in both Elm and Mint as they`,`'`,`re the only collection`,`
`,`data type that allows mixed types in the collection.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, tuples are limited to only 2 or 3 entries. It is recommended to use`,`
`,`records when needing larger numbers of entries.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`myTuple = ("username", "password", 10)`]),A('span',{class:"line"},[`(_, password, _) = myTuple`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, tuples need to have at least 2 entities (one entity is a variable)`,`
`,`and have no upper limits, but records are still recommended as giving names`,`
`,`to fields adds clarity.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`myTuple`]),` = {`,A('span',{class:"string"},[`"username"`]),`, `,A('span',{class:"string"},[`"password"`]),`, `,A('span',{class:"number"},[`10`]),`}
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` {`,A('span',{class:"variable"},[`username`]),`, `,A('span',{class:"variable"},[`password`]),`, `,A('span',{class:"variable"},[`age`]),`} = `,A('span',{class:"variable"},[`myTuple`])])])]),A('h3',{},[`Records`]),A('p',{},[`Records are used to define and create structured data.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, you can declare records using curly braces containing key-value`,`
`,`pairs:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`person =`]),A('span',{class:"line"},[`  { name = "Alice"`]),A('span',{class:"line"},[`  , age = 43`]),A('span',{class:"line"},[`  }`])])]),A('p',{},[`The type of the record is derived by the compiler. In this case, it`,`
`,`would be:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`{ name : String, age : number }`])])]),A('p',{},[`Record fields can be accessed with a dot syntax:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`greeting person =`]),A('span',{class:"line"},[`  "Hello, " ++ person.name ++ "!"`])])]),A('p',{},[`Records cannot be updated because they are immutable. However, there`,`
`,`is a special syntax for easily creating a new record based on an`,`
`,`existing record`,`'`,`s fields:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`personWithSameAge = { person | name = "Bob" }`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, you cannot create records without creating a custom type first, if`,`
`,`you try it will result in a compile-time error.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`type`]),` `,A('span',{class:"type"},[`Person`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"type"},[`String`]),`,
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`age`]),`: `,A('span',{class:"type"},[`Int`]),`
`]),A('span',{class:"line"},[`}
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`alice`]),` = { `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"string"},[`"Alice"`]),`, `,A('span',{class:"variable"},[`age`]),`: `,A('span',{class:"number"},[`43`]),` }
`]),A('span',{class:"line"},[``,A('span',{class:"comment"},[`// no compile time error since it matches the type above`]),`
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`grace`]),` = { `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"string"},[`"Grace"`]),`, `,A('span',{class:"variable"},[`age`]),`: `,A('span',{class:"number"},[`26`]),`, `,A('span',{class:"variable"},[`hair`]),`: `,A('span',{class:"string"},[`"Long"`]),` }
`]),A('span',{class:"line"},[``,A('span',{class:"comment"},[`// results in a compile time error, no type matches the structure`])])])]),A('p',{},[`Record fields can be accessed with a dot syntax:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`greeting`]),` =
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Array`]),`.`,A('span',{class:"variable"},[`join`]),`([`,A('span',{class:"string"},[`"Hello, "`]),`,  `,A('span',{class:"variable"},[`person`]),`.`,A('span',{class:"variable"},[`name`]),`, `,A('span',{class:"string"},[`"!"`]),`])`])])]),A('p',{},[`Records cannot be updated because they are immutable. However, there`,`
`,`is a special syntax for easily creating a new record based on an`,`
`,`existing record`,`'`,`s fields:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`personWithSameAge`]),` = { `,A('span',{class:"variable"},[`person`]),` | `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"string"},[`"Bob"`]),` }`])])]),A('h3',{},[`Lists / Arrays`]),A('p',{},[`Both Elm and Mint support containers of items, where all items have to be of`,`
`,`the same type.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm has a built-in syntax for lists and the `,A('code',{},[`cons`]),` operator (`,A('code',{},[`::`]),`) for`,`
`,`adding a new item to the head of a list.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`list = [2, 3, 4]`]),A('span',{class:"line"},[`anotherList = 1 :: list`]),A('span',{class:"line"},[`yetAnotherList = "hello" :: list // compile error, type mismatch`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint has a built-in syntax for arrays (`,A('code',{},[`Array(a)`]),`) and no special syntax`,`
`,`for appending or prepending, only functions.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`array`]),` = [`,A('span',{class:"number"},[`2`]),`, `,A('span',{class:"number"},[`3`]),`, `,A('span',{class:"number"},[`4`]),`]`])])]),A('p',{},[`Arrays are immutable (just like any other values) so any modification`,`
`,`results in a new array instead.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`array`]),` = [`,A('span',{class:"number"},[`2`]),`, `,A('span',{class:"number"},[`3`]),`, `,A('span',{class:"number"},[`4`]),`]
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`modified`]),` = `,A('span',{class:"type"},[`Array`]),`.`,A('span',{class:"variable"},[`unshift`]),`(`,A('span',{class:"variable"},[`array`]),`, `,A('span',{class:"number"},[`1`]),`)`])])]),A('h3',{},[`Dicts / Maps`]),A('p',{},[`Dict in Elm and Map in Mint have similar properties and purpose.`]),A('p',{},[`In Mint, maps can have keys and values of any type, but all keys must be of`,`
`,`the same type in a given map and all values must be of the same type in a`,`
`,`given map.`]),A('p',{},[`Like Elm, there is no map literal syntax in Mint, and you cannot pattern`,`
`,`match on a map.`]),A('p',{},[A('strong',{},[`Elm`])]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`import Dict`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`Dict.fromList [ ("key1", "value1"), ("key2", "value2") ]`]),A('span',{class:"line"},[`Dict.fromList [ ("key1", "value1"), ("key2", 2) ] -- Compile error`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"type"},[`Map`]),`.`,A('span',{class:"variable"},[`fromArray`]),`([{`,A('span',{class:"string"},[`"key1"`]),`, `,A('span',{class:"string"},[`"value1"`]),`}, {`,A('span',{class:"string"},[`"key2"`]),`, `,A('span',{class:"string"},[`"value2"`]),`}])
`]),A('span',{class:"line"},[``,A('span',{class:"type"},[`Map`]),`.`,A('span',{class:"variable"},[`fromArray`]),`([{`,A('span',{class:"string"},[`"key1"`]),`, `,A('span',{class:"string"},[`"value1"`]),`}, {`,A('span',{class:"string"},[`"key2"`]),`, `,A('span',{class:"number"},[`2`]),`}]) `,A('span',{class:"comment"},[`// Type error!`])])])]),A('h2',{},[`Operators`]),A('p',{},[`Operators in Mint work the same as in Elm, expect for concatenation which`,`
`,`is `,A('code',{},[`++`]),` in Elm and `,A('code',{},[`+`]),` in Mint.`]),A('p',{},[`Check the `,A('a',{href:"/reference/operators"},[`operators reference`]),` for more information.`]),A('h2',{},[`Type Aliases`]),A('p',{},[`Elm uses type aliases to define the layout of records. Mint uses Custom`,`
`,`Types to achieve a similar result.`]),A('p',{},[`Mint`,`'`,`s custom types allow you to define a collection data type with a fixed`,`
`,`number of named fields, and the values in those fields can be of differing`,`
`,`types.`]),A('p',{},[A('strong',{},[`Elm`])]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`type alias Person =`]),A('span',{class:"line"},[` { name : String`]),A('span',{class:"line"},[` , age : Int`]),A('span',{class:"line"},[` }`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`person = Person "Jake" 35`]),A('span',{class:"line"},[`name = person.name`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint`,`'`,`s custom types can be used in much the same way. At runtime, they are`,`
`,`plain JavaScript objects, so there is little overhead.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`type`]),` `,A('span',{class:"type"},[`Person`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"type"},[`String`]),`,
`]),A('span',{class:"line"},[`  `,A('span',{class:"variable"},[`age`]),`: `,A('span',{class:"type"},[`Int`]),`
`]),A('span',{class:"line"},[`}
`]),A('span',{class:"line"},[`
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`person`]),` = { `,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"string"},[`"Jake"`]),`, `,A('span',{class:"variable"},[`age`]),`: `,A('span',{class:"number"},[`35`]),` }
`]),A('span',{class:"line"},[``,A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`name`]),` = `,A('span',{class:"variable"},[`person`]),`.`,A('span',{class:"variable"},[`name`])])])]),A('h2',{},[`Custom Types`]),A('p',{},[`Both Elm and Mint have a similar concept of custom types. These allow you`,`
`,`to list out the different states that a particular piece of data might have.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`The following example might represent a user in a system:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`type User`]),A('span',{class:"line"},[`  = LoggedIn String  -- A logged in user with a name`]),A('span',{class:"line"},[`  | Guest            -- A guest user with no details`])])]),A('p',{},[`You must use a case-expression to interact with the contents of a value`,`
`,`that uses a custom type:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`getName : User -> String`]),A('span',{class:"line"},[`getName user =`]),A('span',{class:"line"},[`  case user of`]),A('span',{class:"line"},[`    LoggedIn name ->`]),A('span',{class:"line"},[`      name`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`    Guest ->`]),A('span',{class:"line"},[`      "Guest user"`])])]),A('p',{},[`A custom type with a single entry can be used to help create opaque data`,`
`,`types for your module`,`'`,`s API if only the type and not the single constructor`,`
`,`is exported.`]),A('p',{},[A('strong',{},[`Mint`])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`type`]),` `,A('span',{class:"type"},[`User`]),` {
`]),A('span',{class:"line"},[`  `,A('span',{class:"comment"},[`// A logged in user with a name`]),`
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`LoggedIn`]),`(`,A('span',{class:"variable"},[`name`]),`: `,A('span',{class:"type"},[`String`]),`)
`]),A('span',{class:"line"},[`  `,A('span',{class:"comment"},[`// A guest user with no details`]),`
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Guest`]),`
`]),A('span',{class:"line"},[`}`])])]),A('p',{},[`Like in Elm, you must use a case-expression to interact with the contents`,`
`,`of a value that uses a custom type.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` getName (`,A('span',{class:"variable"},[`user`]),` : `,A('span',{class:"type"},[`User`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`case`]),` `,A('span',{class:"variable"},[`user`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`LoggedIn`]),`(`,A('span',{class:"variable"},[`name`]),`) => `,A('span',{class:"variable"},[`name`]),`
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`Guest`]),` => `,A('span',{class:"string"},[`"Guest user"`]),`
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}`])])]),A('p',{},[`There are no opaque data types in Mint.`]),A('h3',{},[`Maybe`]),A('p',{},[`Neither Mint nor Elm have a concept of `,`'`,`null`,`'`,` in their type system. Both`,`
`,`languages use `,A('code',{},[`Maybe`]),` to handle this case.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`In Elm, `,A('code',{},[`Maybe`]),` is defined as:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`type Maybe a`]),A('span',{class:"line"},[`  = Nothing`]),A('span',{class:"line"},[`  | Just a`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`In Mint, `,A('code',{},[`Maybe`]),` is defined as:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`type`]),` `,A('span',{class:"type"},[`Maybe`]),`(`,A('span',{class:"type_parameter"},[`a`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Nothing`]),`
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Just`]),`(`,A('span',{class:"type_parameter"},[`a`]),`)
`]),A('span',{class:"line"},[`}`])])]),A('h3',{},[`Result`]),A('p',{},[`Neither Mint nor Elm have exceptions and instead represent failures using`,`
`,`the `,A('code',{},[`Result`]),` type.`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm`,`'`,`s `,A('code',{},[`Result`]),` type is defined as:`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`type Result error value`]),A('span',{class:"line"},[`  = Err error`]),A('span',{class:"line"},[`  | Ok value`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint`,`'`,`s `,A('code',{},[`Result`]),` type is defined as:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`type`]),` `,A('span',{class:"type"},[`Result`]),`(`,A('span',{class:"type_parameter"},[`error`]),`, `,A('span',{class:"type_parameter"},[`value`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Error`]),`(`,A('span',{class:"type_parameter"},[`error`]),`)
`]),A('span',{class:"line"},[`  `,A('span',{class:"type"},[`Ok`]),`(`,A('span',{class:"type_parameter"},[`value`]),`)
`]),A('span',{class:"line"},[`}`])])]),A('h2',{},[`If expressions`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm has syntax for if-expressions for control flow based on boolean values.`]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`description =`]),A('span',{class:"line"},[`  if value then`]),A('span',{class:"line"},[`    "It's true!"`]),A('span',{class:"line"},[`  else`]),A('span',{class:"line"},[`    "It's not true."`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint also has a built-in if-expression syntax.`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`description`]),` =
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`if`]),` `,A('span',{class:"variable"},[`value`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"string"},[`"It's true!"`]),`
`]),A('span',{class:"line"},[`  } `,A('span',{class:"keyword"},[`else`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"string"},[`"It's not true."`]),`
`]),A('span',{class:"line"},[`  }`])])]),A('h2',{},[`Case expressions`]),A('p',{},[`Both Mint and Elm support case-expressions for pattern matching on values,`,`
`,`including custom types.`]),A('p',{},[A('strong',{},[`Elm`])]),A('pre',{},[A('code',{class:"language-elm"},[A('span',{class:"line"},[`getName : User -> String`]),A('span',{class:"line"},[`getName user =`]),A('span',{class:"line"},[`  case user of`]),A('span',{class:"line"},[`    LoggedIn name ->`]),A('span',{class:"line"},[`      name`]),A('span',{class:"line"},[``]),A('span',{class:"line"},[`    Guest ->`]),A('span',{class:"line"},[`      "Guest user"`])])]),A('p',{},[A('strong',{},[`Mint`])]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`fun`]),` getName(`,A('span',{class:"variable"},[`user`]),` : `,A('span',{class:"type"},[`User`]),`) {
`]),A('span',{class:"line"},[`  `,A('span',{class:"keyword"},[`case`]),` `,A('span',{class:"variable"},[`user`]),` {
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`LoggedIn`]),`(`,A('span',{class:"variable"},[`name`]),`) => `,A('span',{class:"variable"},[`name`]),`
`]),A('span',{class:"line"},[`    `,A('span',{class:"type"},[`Guest`]),` => `,A('span',{class:"string"},[`"Guest user"`]),`
`]),A('span',{class:"line"},[`  }
`]),A('span',{class:"line"},[`}`])])]),A('h2',{},[`Talking to JavaScript`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm programs compile to JavaScript and primarily allow you to talk to`,`
`,`JavaScript via `,A('a',{href:"https://guide.elm-lang.org/interop/ports.html"},[`ports`]),`.`,`
`,`Elm does not have an accessible foreign function interface for calling`,`
`,`JavaScript directly from Elm code. Only core modules can do that. Ports`,`
`,`provide a message-passing interface between the Elm application and`,`
`,`JavaScript. It is very safe. It is almost impossible to cause runtime`,`
`,`errors in your Elm code by passing incorrect values to or from ports.`,`
`,`This makes Elm a very safe language with very good guarantees against`,`
`,`runtime exceptions but at the cost of some friction when the developer`,`
`,`wants to interact with JavaScript.`]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint has `,A('strong',{},[`inlining`]),` for talking to JavaScript is, which means that you can`,`
`,`write JavaScript code between backticks:`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[A('span',{class:"keyword"},[`let`]),` `,A('span',{class:"variable"},[`confirmed`]),` = \`window.confirm("Are you sure")\` `,A('span',{class:"keyword"},[`as`]),` `,A('span',{class:"type"},[`Bool`])])])]),A('p',{},[`This is `,A('strong',{},[`unsafe`]),`, so when using is make sure you always wrap it in a`,`
`,A('code',{},[`try`]),` statement and handle any error that might happen.`]),A('h2',{},[`Commands`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm is a pure language so all side effects, e.g. making an HTTP request, are`,`
`,`managed by the command system. This means that functions for making HTTP`,`
`,`requests return an opaque command value that you return to the runtime,`,`
`,`normally via the update function, in order to execute the request.`]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint is not a pure language and so does not have a command system for`,`
`,`managing side effects. Any function can directly perform side effects and`,`
`,`where necessary will manage success and failure using the `,A('code',{},[`Result`]),` type or`,`
`,`other more specific custom types.`]),A('h2',{},[`Architecture`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm has `,`'`,`The Elm architecture`,`'`,` baked into the language and the core modules.`,`
`,`Generally speaking, all Elm applications follow the Elm architecture.`]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint uses `,A('a',{href:"/reference/components/introduction"},[`components`]),` to encapsulate`,`
`,`code for a part of the UI, they can be  composed in each other and can`,`
`,`connect to `,A('a',{href:"/reference/stores"},[`stores`]),` for handling data.`]),A('h2',{},[`Package management`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`Elm packages are installed via the `,A('code',{},[`elm install`]),` command and are hosted on`,`
`,A('a',{href:"https://package.elm-lang.org/"},[`package.elm-lang.org`]),`.`]),A('p',{},[`All third-party Elm packages are written in pure Elm. It is not possible`,`
`,`to publish an Elm package that includes JavaScript code unless you are in`,`
`,`the core team. Some packages published under the `,A('code',{},[`elm`]),` and`,`
`,A('code',{},[`elm-explorations`]),` namespaces have JavaScript internals.`]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`Mint packages are installed via the `,A('code',{},[`mint install`]),` command and are hosted`,`
`,`as Git repositories.`]),A('p',{},[`There are no restrictions on publishing packages with JavaScript code in`,`
`,`them or that wrap JavaScript libraries.`]),A('h2',{},[`Implementation`]),A('p',{},[A('strong',{},[`Elm`])]),A('p',{},[`The Elm compiler is written in `,A('a',{href:"https://www.haskell.org/"},[`Haskell`]),` and`,`
`,`distributed primarily via `,A('a',{href:"https://www.npmjs.com/"},[`npm`]),`. The core libraries`,`
`,`are written in a mix of Elm and JavaScript.`]),A('p',{},[A('strong',{},[`Mint`])]),A('p',{},[`The Mint compiler is written in `,A('a',{href:"https://crystal-lang.org/"},[`Crystal`]),` and`,`
`,`distributed as `,A('a',{href:"/install"},[`precompiled binaries`]),`. The core libraries are`,`
`,`written in a mix of Mint and JavaScript.`])]),b=a;export default b;