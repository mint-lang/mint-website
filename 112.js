import {createElement as A,fragment as B,style as C} from "./runtime.js";export const a=(b,c)=>{return (b.reduce((array, value)=>[...array, value, c], []).slice(0,-1))},d=(()=>{const e=[[`|>`,0,[`a |> Function(a, b)`],[`b`],`Pipes the left side to the function on the right`],[`or`,0,[`Maybe(a) or a`,`Result(err, a) or a`],[`a`,`a`],A(B,{},[A('p',{},[`Falls back to the right side if left side is `,A('code',{},[`Maybe.Nothing`]),` or`,`
`,A('code',{},[`Result.Err`])])])],[`&&`,6,[`Bool && Bool`],[`Bool`],`Logical AND (short circuiting)`],[`||`,5,[`Bool && Bool`],[`Bool`],`Logical OR (short circuiting)`],[`!=`,10,[`a != a`],[`Bool`],`Inequality`],[`==`,10,[`a == a`],[`Bool`],`Equality`],[`<=`,11,[`Number <= Number`],[`Bool`],`Less than or equal to`],[`>=`,11,[`Number >= Number`],[`Bool`],`More than or equal to`],[`<`,11,[`Number < Number`],[`Bool`],`Less than`],[`>`,11,[`Number > Number`],[`Bool`],`More than`],[`-`,13,[`Number - Number`],[`Number`],`Substraction`],[`+`,13,[`String + String`,`Number + Number`],[`String`,`Number`],`Addition and string concatenation`],[`*`,14,[`Number * Number`],[`Number`],`Multipication`],[`/`,14,[`Number / Number`],[`Number`],`Division (float)`],[`%`,14,[`Number % Number`],[`Number`],`Remainder (float)`],[`**`,15,[`Number ** Number`],[`Number`],`Exponentiation`],[`!`,16,[`!Bool`],[`Bool`],`Negation`]];const f=A(`table`,{},[A(`thead`,{},[A(`tr`,{},[A(`th`,{},[`Operator`]),A(`th`,{},[`Precedence`]),A(`th`,{},[`Type Restriction`]),A(`th`,{style:C([`white-space: nowrap`])},[`Result Type`]),A(`th`,{},[`Description`])])]),A(`tbody`,{},[(()=>{const _0=[];const _1=e;let _i=-1;for(let g of _1){_i++;_0.push(A(`tr`,{},[A(`td`,{},[A(`code`,{},[g[0]])]),A(`td`,{},[A(`code`,{},[`${g[1]}`])]),A(`td`,{},[a((()=>{const _0=[];const _1=g[2];let _i=-1;for(let h of _1){_i++;_0.push(A(`code`,{style:C([`white-space: nowrap;`])},[h]))};return _0})(),A(`br`,{}))]),A(`td`,{},[a((()=>{const _0=[];const _1=g[3];let _i=-1;for(let i of _1){_i++;_0.push(A(`code`,{},[i]))};return _0})(),A(`br`,{}))]),A(`td`,{},[g[4]])]))};return _0})()])]);return A(B,{},[A('h1',{},[`Operators`]),A('p',{},[`Mint supports a number of fixed operators. Some work on specific types,`,`
`,`some on all types, see the table below for specifics:`]),A('p',{},[``,f,``]),A('h2',{},[`Controlling Precedence`]),A('p',{},[`If you want to explicitly control the precedence you can wrap the`,`
`,`operation in parentheses `,A('code',{},[`(...)`]),` or brackets `,A('code',{},[`{...}`]),` (which are basically`,`
`,`just `,A('a',{href:"/reference/blocks"},[`blocks`]),`).`]),A('pre',{},[A('code',{class:"language-mint"},[A('span',{class:"line"},[`(`,A('span',{class:"number"},[`10`]),` `,A('span',{class:"operator"},[`*`]),` `,A('span',{class:"number"},[`4`]),`) `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"number"},[`2`]),`
`]),A('span',{class:"line"},[`{`,A('span',{class:"number"},[`10`]),` `,A('span',{class:"operator"},[`*`]),` `,A('span',{class:"number"},[`4`]),`} `,A('span',{class:"operator"},[`+`]),` `,A('span',{class:"number"},[`2`])])])])])})(),j=d;export default j;